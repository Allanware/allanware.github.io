<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>My Leetcode Journey | Wenxuan Zhao</title>
<meta name=keywords content><meta name=description content="This post documents my journey wading through leetcode."><meta name=author content="Wenxuan Zhao"><link rel=canonical href=https://allanware.github.io/posts/2023/10/my-leetcode-journey/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://allanware.github.io/favicons/favicon.png><link rel=icon type=image/png sizes=16x16 href=https://allanware.github.io/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://allanware.github.io/favicons/favicon-32x32.png><link rel=apple-touch-icon href=https://allanware.github.io/favicons/apple-touch-icon.png><link rel=mask-icon href=https://allanware.github.io/favicons/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://allanware.github.io/posts/2023/10/my-leetcode-journey/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-Y7CDN6L98B"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-Y7CDN6L98B",{anonymize_ip:!1})}</script><meta property="og:title" content="My Leetcode Journey"><meta property="og:description" content="This post documents my journey wading through leetcode."><meta property="og:type" content="article"><meta property="og:url" content="https://allanware.github.io/posts/2023/10/my-leetcode-journey/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-22T11:42:45-05:00"><meta property="article:modified_time" content="2023-10-24T16:42:21-05:00"><meta property="og:site_name" content="Wenxuan Zhao"><meta name=twitter:card content="summary"><meta name=twitter:title content="My Leetcode Journey"><meta name=twitter:description content="This post documents my journey wading through leetcode."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://allanware.github.io/posts/"},{"@type":"ListItem","position":2,"name":"My Leetcode Journey","item":"https://allanware.github.io/posts/2023/10/my-leetcode-journey/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"My Leetcode Journey","name":"My Leetcode Journey","description":"This post documents my journey wading through leetcode.","keywords":[""],"articleBody":"1768. Merge Strings Alternately Approach 1: Double pointers i, j points to word1 and word2. A while loop that does the traversing and appending. To traverse two lists throughly, we check for i \u003c len(words1) or j \u003c len(words2).\nInside while loop, result list appends words1[i] if i \u003c len(words1) and words2[j] if j \u003c len(words2).\nNote: in Python, strings are immutable, we used the list result to append letters and later joined the list with an empty string to return it as a string object. The join operation takes linear time equal to the length of results to merge results with empty string.\nTime $O(m+n)$: m is the length of word1, n is the length of word2.\nSpace $O(n)$: we use a temp list result to store the final string.\nApproach 2: One pointer To traverse two lists throughly, we could also check for i \u003c max(len(word1), len(word2)).\nInside while/for loop, result list appends words1[i] if i \u003c len(words1) and words2[j] if j \u003c len(words2).\n1071. Greatest Common Divisor of Strings Approach 1: Analgous to math GCD Denote len(str1) = m, len(str1) = n.\nif m \u003e n, gcdString = gcd(str1 - str2, str2), and vice versa. str1 - str2 means deleting str2 from the start of str1. If there is any mismatch, then there is no gcd string (return \"\" as gcdString).\nBase case: if str1 == “”, return str2; vice versa\nTime We need to scan the longest string of str1 and str2 once: $O(max(m+n))$\nSpace $O(1)$ if we can modify string in place.\n605. Can Place Flowers Approach Greedy algorithm + padding the front and the end of the array. If a spot is plantable, then +2 to find the next via spot.\nIf the array is not allowed to change, we could create a new array with paddings, or we could handle the front and end very carefully.\nWe could return True early if n is already 0 (assuming each time we find a spot we decrement n by 1).\nTime We need to scan the array once: $O(n)$.\nSpace $O(1)$\n345. Reverse Vowels of a String Approach Python string is immutable. First convert input string to a list to enable in-place swap. After that, use \"\".join(stringList) to convert the list back to string. Use a dictionary to store the vowels. Use double pointers, one pointing at the front, and another pointing at the back. Use a while loop to make sure they do not cross. Inside the while loop: use two while loops for i and j to find vowels, and make sure they do not touch. If they haven’t touched after the two while loops, then they must find a pair of vowels =\u003e we do the swap. Time We need to scan the string once: $O(n)$.\nSpace $O(n)$\n151. Reverse Words in a String Approach Similar to the above problem. Use .split() split a string into a list of words. The default delimiter to split is any number of white spaces. Use double pointers to swap. Time $O(n)$\nSpace $O(n)$\n1137. N-th Tribonacci Number Approach To solve it and not use recursion, which is of exponential complexity, we use a dynamic programming technique:\nuse an array of size n+1 to store the partial results along computing $T_n$ initialize $T_0, T_1, T_2$ use for loop to compute $T_n$ Time: $O(n)$\nSpace $O(n)$\n238. Product of Array Except Self Approach For each number in the array, to get the product of everything besides it, we can divide the problem into two halves: multiply the numbers on the left and store the result, then multiply the numbers on the right.\nThe key point is to store the partial result in an variable, and update the slots in the output array with the corresponding partial result.\nTime: $O(n)$\nSpace $O(1)$\n283. Move Zeroes Approach 1 This problem is under the section Two Pointers. I approach this problem by setting the one pointer to keep track of the first 0 on the left (the first swap position), and the other pointer to the next non-zero number (use a while loop).\nApproach 2: Fast and Slow pointer The fast pointer iterates faster than the slower one. But they should end at about the same time. So I use a for loop to iterates the fast pointer over the whole array, and only updates the slow pointer if it points to a non-zero. Like the previous approach, essentially the fast will keep track of the non-zero, the slow keeps track of the first zero. But the structure of a for loop to update the fast, and inside the loop an if to conditionally update slow is much cleaner than approach 1.\nTime: $O(n)$\nSpace $O(1)$\n392. Is Subsequence Approach: fast and slow pointer To check if s is a substring of t, the fast pointer iterates over t, and the slow pointer iterates over s. If the iterator of s points to beyond the end of s, then we know s is a substring of t. We also use a similair structure to the above problem: a for loop for t; inside for loop, use a if to iterate s if we find a characet match.\nTime: $O(n)$\nSpace $O(1)$\n643. Maximum Average Subarray I Approach: Sliding window If we were to average every window, the complexity is $O(k*n)$. To make it linearly dependent on n, we observe that for each window, we only need to keep track of the changes between each window: subtract the left, add the right. My first thought was if we can find an i such that nums[i] \u003c nums[i+k], then we update maxI to this new i. However, this only work locally, namely, if we compare two contiguous windows. It doesn’t word between two non-neighbors since they do not share the middle two elements. Thus, we also need to track the sum and maxSum.\nTime: $O(n)$\nSpace $O(1)$\n724. Find Pivot Index Approach: Sliding window Use leftSum and rightSum to store the sum of left and right elements of the potential pivot. If leftSum == rightSum, we find the pivot.\nWe use the sliding window approach to update leftSum and rightSum. Init leftSum to 0 and rightSum to sum(nums)-nums[0] for i=0 .\nTime: $O(n)$\nSpace $O(1)$\n2215. Find the Difference of Two Arrays Approach: set difference answer[0] = set(nums1) - set(nums2)\nanswer[1] = set(nums2) - set(nums1)\nTime: $O(n)$\nSpace $O(n)$\n1207. Unique Number of Occurrences Approach Create a dictionary; Loop through the array, and insert the element into the dictionary or increment the counter for the existing key; If the size of the dictionary (number of keys) is the same as the unique values of the counters of those keys, then we know each key (each unique element in array) has a unique number of appearances.\nTime: $O(n)$\nSpace $O(n)$\n2390. Removing Stars From a String Approach To “Remove the closest non-star character to its left, as well as remove the star itself”, we can use a stack to simulate this process: read the string from left to right (start to end), when we see a non star, we push it to the stack. When we see a star, we pop the last element we pushed (LIFO).\nIn Python, we can use deque in collections, because it offers $O(1)$ insertion at both the right end (append) and the left enb (appendleft) and $O(1)$ pop (pop) at the right and the left end (popleft).\nTime: $O(n)$\nSpace $O(1)$\n735. Asteroid Collision Approach Use deque to simulate stack in python. Make sure the element to be pushed on top of the stack is compatible with elements inside the stack before pushing it.\nInvariants:\nIf the stack is empty, push the next element in the array. If the top element in the stack is negative, push the next element in array no matter it is negative or positive. If the next element is positive, just push it. Else (top is positive, next element is negative): crush whatever can be crushed by the next element in the stack: a while loop Time: $O(n^2)$\nSpace $O(1)$\n933. Number of Recent Calls Approach t is in strictly increasing order. If some ping falls outside of the range, it must be in the start of the ping array. This behavior can be simulated using queue (FIFO).\nIn python, we can use deque to implement a queue: append to push, popleft to pop.\nTime: $O(n)$\nSpace $O(1)$\n2095. Delete the Middle Node of a Linked List Approach To fid the middle node, we could use the “fast” and “slow” double pointer method. Inside the while loop, by updating the “fast” pointer twice and the “slow” pointer once, we can locate the mid node at the “slow” pointer.\nTo delete it, we can use another pointer to point to the prev of the “slow” pointer, and update prev.next to its next.next.\nTime: $O(n)$\nSpace $O(1)$\n328. Odd Even Linked List Appraoch The intuition is to maintain a double-pointer structure to this linked-list: the oddNode pointer that first points to the head and the evenNode pointer that first points to head.next .\nMy first try was to update oddNode.next = oddNode.next.next in a while loop, which essentially gets the oddNode list ready. Then I update the evenNode list similarly. But this did not work, because evenNode.next is the updated oddNode not the original oddNode, and evenNode.next.next is not a evenNode.\nTo account for that, we need to carefully update oddNode and evenNode in turn. Another thing is that we need to store the head.next in a special variable evenListStart so that the last oddNode knows where it should point to. The last evenNode should point to None.\nTime: $O(n)$\nSpace $O(1)$\n206. Reverse Linked List Approach We traverse the linked list and do this:\nStore currentNode.next to nextNode. Set currentNode.next to prevNode Update prevNode to currentNode Update currentNode to nextNode We need to handle the head and the end of the list a little differently: head of the list does not have prevNode: therefore in step 2, set it to None. End of the list does not have nextNode (equals None), if we know it is None, we know it is the end and we set it to be the new head. Time: $O(n)$\nSpace $O(1)$\n104. Maximum Depth of Binary Tree Background: Tree traversal Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways.\nTraversal using DFS Inorder Traversal (left, root, right) Inorder traversal gives nodes in non-decreasing order.\nImplementation: Iterative: Keep appending left nodes to the stack until hitting None Pop the stack to get the node and print it. Go to its right. Goes back to the above step. Recursive: InorderTravese(root.left) Print (root) InorderTravese(root.right) Time and Space Time: $O(n)$\nSpace: $O(h)$, $h$ is the height of the tree. In the iterative case, $h = len(stack)$. In the recursive case: $h = len(functionStack)$\nPreorder Traversal (root, left, right) Preorder traversal is used to create a copy of the tree.\nImplementation: Iterative: The right child is pushed before the left child to make sure that the left subtree is processed first.\nPop an item from the stack and print it. Push right child of a popped item to stack Push left child of a popped item to stack Recursive:\nPrint (root) PreorderTravese(root.left) PreorderTravese(root.right) Time and Space The same as InorderTraverse.\nPostorder Traversal (left, right, root) Postorder traversal is used to delete the tree.\nLevel Order Traversal (BFS Traversal) Traverse all the nodes of a lower level before moving to any of the nodes of a higher level.\nImplementation Iterative: Visit the root and push all its children to the queue. Pop the queue and visit the popped node and push all its children to queue. Repeat until queue is empty. Approach Recursively Using DFS. If the node is None, return 0. Otherwise, return max(maxDepth(node.left), maxDepth(node.right)) + 1\nTime: $O(n)$\nSpace $O(h)$: h = Max height of the tree.\n338. Counting Bits Approach To do it in linear time, the intuition is to use dynamic programming: reuse the result in smaller is (i from 1 to n) to compute big is.\nOne way to do this is to divide i by 2 by using i\u003e\u003e1 and access output[i\u003e\u003e1] to get the number of 1s besides the last digit. If the last digit is 1, then we add 1 to the above number; otherwise, add 0. To check if the last digit is 1 or not, we can use i\u00261.\nTime: $O(n)$\nSpace $O(1)$\n136. Single Number Since besides the singled number the list contains numbers all in pair. To cancel themselves out, we can use xor (^ in python). We can xor the whole list together and what remains is the single number.\nTime: $O(n)$\nSpace $O(1)$\n1. Two Sum Approach I did not figure it out myself. The most obvious solution is to use a $O(n^2)$ brute-force method. I then try to reduce it to $O(n\\log{n})$ by first sorting it, and then use binary search to search for each element’s complement in the list. That is another $O(n\\log{n})$. This doesn’t work becasue the numbers could be negative and the target sum could be acheived by summing\n","wordCount":"2210","inLanguage":"en","datePublished":"2023-10-22T11:42:45-05:00","dateModified":"2023-10-24T16:42:21-05:00","author":{"@type":"Person","name":"Wenxuan Zhao"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://allanware.github.io/posts/2023/10/my-leetcode-journey/"},"publisher":{"@type":"Organization","name":"Wenxuan Zhao","logo":{"@type":"ImageObject","url":"https://allanware.github.io/favicons/favicon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://allanware.github.io/ accesskey=h title="Wenxuan Zhao (Alt + H)">Wenxuan Zhao</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://allanware.github.io/zh/ title=中文 aria-label=中文>Zh</a></li></ul></div></div><ul id=menu><li><a href=https://allanware.github.io/ title=Home><span>Home</span></a></li><li><a href=https://allanware.github.io/about/ title=About><span>About</span></a></li><li><a href=https://allanware.github.io/life/ title=Life><span>Life</span></a></li><li><a href=https://allanware.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://allanware.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://allanware.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://allanware.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://allanware.github.io/posts/>Posts</a></div><h1 class=post-title>My Leetcode Journey</h1><div class=post-meta><span title='2023-10-22 11:42:45 -0500 -0500'>October 22, 2023</span>&nbsp;·&nbsp;<span title='2023-10-24 16:42:21 -0500 -0500'>(updated October 24, 2023)</span>&nbsp;·&nbsp;Wenxuan Zhao</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1768-merge-strings-alternatelyhttpsleetcodecomproblemsmerge-strings-alternately aria-label="1768. Merge Strings Alternately"><a href=https://leetcode.com/problems/merge-strings-alternately/>1768. Merge Strings Alternately</a></a><ul><li><a href=#approach-1-double-pointers aria-label="Approach 1: Double pointers">Approach 1: Double pointers</a><ul><li><a href=#time aria-label=Time>Time</a></li><li><a href=#space aria-label=Space>Space</a></li></ul></li><li><a href=#approach-2-one-pointer aria-label="Approach 2: One pointer">Approach 2: One pointer</a></li></ul></li><li><a href=#1071-greatest-common-divisor-of-stringshttpsleetcodecomproblemsgreatest-common-divisor-of-strings aria-label="1071. Greatest Common Divisor of Strings"><a href=https://leetcode.com/problems/greatest-common-divisor-of-strings/>1071. Greatest Common Divisor of Strings</a></a><ul><li><a href=#approach-1-analgous-to-math-gcd aria-label="Approach 1: Analgous to math GCD">Approach 1: Analgous to math GCD</a><ul><li><a href=#time-1 aria-label=Time>Time</a></li><li><a href=#space-1 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#605-can-place-flowershttpsleetcodecomproblemscan-place-flowers aria-label="605. Can Place Flowers"><a href=https://leetcode.com/problems/can-place-flowers/>605. Can Place Flowers</a></a><ul><li><a href=#approach aria-label=Approach>Approach</a><ul><li><a href=#time-2 aria-label=Time>Time</a></li><li><a href=#space-2 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#345-reverse-vowels-of-a-stringhttpsleetcodecomproblemsreverse-vowels-of-a-string aria-label="345. Reverse Vowels of a String"><a href=https://leetcode.com/problems/reverse-vowels-of-a-string/>345. Reverse Vowels of a String</a></a><ul><li><a href=#approach-1 aria-label=Approach>Approach</a><ul><li><a href=#time-3 aria-label=Time>Time</a></li><li><a href=#space-3 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#151-reverse-words-in-a-stringhttpsleetcodecomproblemsreverse-words-in-a-string aria-label="151. Reverse Words in a String"><a href=https://leetcode.com/problems/reverse-words-in-a-string/>151. Reverse Words in a String</a></a><ul><li><a href=#approach-2 aria-label=Approach>Approach</a><ul><li><a href=#time-4 aria-label=Time>Time</a></li><li><a href=#space-4 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#1137-n-th-tribonacci-numberhttpsleetcodecomproblemsn-th-tribonacci-number aria-label="1137. N-th Tribonacci Number"><a href=https://leetcode.com/problems/n-th-tribonacci-number/>1137. N-th Tribonacci Number</a></a><ul><li><a href=#approach-3 aria-label=Approach>Approach</a><ul><li><a href=#time-5 aria-label=Time:>Time:</a></li><li><a href=#space-5 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#238-product-of-array-except-selfhttpsleetcodecomproblemsproduct-of-array-except-self aria-label="238. Product of Array Except Self"><a href=https://leetcode.com/problems/product-of-array-except-self/>238. Product of Array Except Self</a></a><ul><li><a href=#approach-4 aria-label=Approach>Approach</a><ul><li><a href=#time-6 aria-label=Time:>Time:</a></li><li><a href=#space-6 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#283-move-zeroeshttpsleetcodecomproblemsmove-zeroes aria-label="283. Move Zeroes"><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a></a><ul><li><a href=#approach-1-1 aria-label="Approach 1">Approach 1</a></li><li><a href=#approach-2-fast-and-slow-pointer aria-label="Approach 2: Fast and Slow pointer">Approach 2: Fast and Slow pointer</a><ul><li><a href=#time-7 aria-label=Time:>Time:</a></li><li><a href=#space-7 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#392-is-subsequencehttpsleetcodecomproblemsis-subsequence aria-label="392. Is Subsequence"><a href=https://leetcode.com/problems/is-subsequence/>392. Is Subsequence</a></a><ul><li><a href=#approach-fast-and-slow-pointer aria-label="Approach: fast and slow pointer">Approach: fast and slow pointer</a><ul><li><a href=#time-8 aria-label=Time:>Time:</a></li><li><a href=#space-8 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#643-maximum-average-subarray-ihttpsleetcodecomproblemsmaximum-average-subarray-i aria-label="643. Maximum Average Subarray I"><a href=https://leetcode.com/problems/maximum-average-subarray-i/>643. Maximum Average Subarray I</a></a><ul><li><a href=#approach-sliding-window aria-label="Approach: Sliding window">Approach: Sliding window</a><ul><li><a href=#time-9 aria-label=Time:>Time:</a></li><li><a href=#space-9 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#724-find-pivot-indexhttpsleetcodecomproblemsfind-pivot-index aria-label="724. Find Pivot Index"><a href=https://leetcode.com/problems/find-pivot-index/>724. Find Pivot Index</a></a><ul><li><a href=#approach-sliding-window-1 aria-label="Approach: Sliding window">Approach: Sliding window</a><ul><li><a href=#time-10 aria-label=Time:>Time:</a></li><li><a href=#space-10 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#2215-find-the-difference-of-two-arrayshttpsleetcodecomproblemsfind-the-difference-of-two-arrays aria-label="2215. Find the Difference of Two Arrays"><a href=https://leetcode.com/problems/find-the-difference-of-two-arrays/>2215. Find the Difference of Two Arrays</a></a><ul><li><a href=#approach-set-difference aria-label="Approach: set difference">Approach: set difference</a><ul><li><a href=#time-11 aria-label=Time:>Time:</a></li><li><a href=#space-11 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#1207-unique-number-of-occurrenceshttpsleetcodecomproblemsunique-number-of-occurrences aria-label="1207. Unique Number of Occurrences"><a href=https://leetcode.com/problems/unique-number-of-occurrences/>1207. Unique Number of Occurrences</a></a><ul><li><a href=#approach-5 aria-label=Approach>Approach</a><ul><li><a href=#time-12 aria-label=Time:>Time:</a></li><li><a href=#space-12 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#2390-removing-stars-from-a-stringhttpsleetcodecomproblemsremoving-stars-from-a-string aria-label="2390. Removing Stars From a String"><a href=https://leetcode.com/problems/removing-stars-from-a-string/>2390. Removing Stars From a String</a></a><ul><li><a href=#approach-6 aria-label=Approach>Approach</a><ul><li><a href=#time-13 aria-label=Time:>Time:</a></li><li><a href=#space-13 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#735-asteroid-collisionhttpsleetcodecomproblemsasteroid-collision aria-label="735. Asteroid Collision"><a href=https://leetcode.com/problems/asteroid-collision/>735. Asteroid Collision</a></a><ul><li><a href=#approach-7 aria-label=Approach>Approach</a><ul><li><a href=#time-14 aria-label=Time:>Time:</a></li><li><a href=#space-14 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#933-number-of-recent-callshttpsleetcodecomproblemsnumber-of-recent-calls aria-label="933. Number of Recent Calls"><a href=https://leetcode.com/problems/number-of-recent-calls/>933. Number of Recent Calls</a></a><ul><li><a href=#approach-8 aria-label=Approach>Approach</a><ul><li><a href=#time-15 aria-label=Time:>Time:</a></li><li><a href=#space-15 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#2095-delete-the-middle-node-of-a-linked-listhttpsleetcodecomproblemsdelete-the-middle-node-of-a-linked-list aria-label="2095. Delete the Middle Node of a Linked List"><a href=https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/>2095. Delete the Middle Node of a Linked List</a></a><ul><li><a href=#approach-9 aria-label=Approach>Approach</a><ul><li><a href=#time-16 aria-label=Time:>Time:</a></li><li><a href=#space-16 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#328-odd-even-linked-listhttpsleetcodecomproblemsodd-even-linked-list aria-label="328. Odd Even Linked List"><a href=https://leetcode.com/problems/odd-even-linked-list/>328. Odd Even Linked List</a></a><ul><li><a href=#appraoch aria-label=Appraoch>Appraoch</a><ul><li><a href=#time-17 aria-label=Time:>Time:</a></li><li><a href=#space-17 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#206-reverse-linked-listhttpsleetcodecomproblemsreverse-linked-list aria-label="206. Reverse Linked List"><a href=https://leetcode.com/problems/reverse-linked-list/>206. Reverse Linked List</a></a><ul><li><a href=#approach-10 aria-label=Approach>Approach</a><ul><li><a href=#time-18 aria-label=Time:>Time:</a></li><li><a href=#space-18 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#104-maximum-depth-of-binary-treehttpsleetcodecomproblemsmaximum-depth-of-binary-tree aria-label="104. Maximum Depth of Binary Tree"><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>104. Maximum Depth of Binary Tree</a></a><ul><li><a href=#background-tree-traversal aria-label="Background: Tree traversal">Background: Tree traversal</a><ul><li><a href=#traversal-using-dfs aria-label="Traversal using DFS">Traversal using DFS</a><ul><li><a href=#inorder-traversal-left-root-right aria-label="Inorder Traversal (left, root, right)">Inorder Traversal (left, root, right)</a><ul><li><a href=#implementation aria-label=Implementation:>Implementation:</a></li><li><a href=#time-and-space aria-label="Time and Space">Time and Space</a></li></ul></li><li><a href=#preorder-traversal-root-left-right aria-label="Preorder Traversal (root, left, right)">Preorder Traversal (root, left, right)</a><ul><li><a href=#implementation-1 aria-label=Implementation:>Implementation:</a></li><li><a href=#time-and-space-1 aria-label="Time and Space">Time and Space</a></li></ul></li><li><a href=#postorder-traversal-left-right-root aria-label="Postorder Traversal (left, right, root)">Postorder Traversal (left, right, root)</a></li></ul></li><li><a href=#level-order-traversal-bfs-traversal aria-label="Level Order Traversal (BFS Traversal)">Level Order Traversal (BFS Traversal)</a><ul><ul><li><a href=#implementation-2 aria-label=Implementation>Implementation</a></li></ul></ul></li></ul></li><li><a href=#approach-11 aria-label=Approach>Approach</a><ul><li><a href=#recursively aria-label=Recursively>Recursively</a></li><li><a href=#time-19 aria-label=Time:>Time:</a></li><li><a href=#space-19 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#338-counting-bitshttpsleetcodecomproblemscounting-bits aria-label="338. Counting Bits"><a href=https://leetcode.com/problems/counting-bits/>338. Counting Bits</a></a><ul><li><a href=#approach-12 aria-label=Approach>Approach</a><ul><li><a href=#time-20 aria-label=Time:>Time:</a></li><li><a href=#space-20 aria-label=Space>Space</a></li></ul></li></ul></li><li><a href=#136-single-numberhttpsleetcodecomproblemssingle-number aria-label="136. Single Number"><a href=https://leetcode.com/problems/single-number/>136. Single Number</a></a><ul><ul><li><a href=#time-21 aria-label=Time:>Time:</a></li><li><a href=#space-21 aria-label=Space>Space</a></li></ul></ul></li><li><a href=#1-two-sumhttpsleetcodecomproblemstwo-sum aria-label="1. Two Sum"><a href=https://leetcode.com/problems/two-sum/>1. Two Sum</a></a><ul><li><a href=#approach-13 aria-label=Approach>Approach</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=1768-merge-strings-alternatelyhttpsleetcodecomproblemsmerge-strings-alternately><a href=https://leetcode.com/problems/merge-strings-alternately/>1768. Merge Strings Alternately</a><a hidden class=anchor aria-hidden=true href=#1768-merge-strings-alternatelyhttpsleetcodecomproblemsmerge-strings-alternately>#</a></h1><h2 id=approach-1-double-pointers>Approach 1: Double pointers<a hidden class=anchor aria-hidden=true href=#approach-1-double-pointers>#</a></h2><p>i, j points to word1 and word2. A while loop that does the traversing and appending. To traverse two lists throughly, we check for <code>i &lt; len(words1)</code> <strong>or</strong> <code>j &lt; len(words2)</code>.</p><p>Inside while loop, result list appends words1[i] if i &lt; len(words1) and words2[j] if j &lt; len(words2).</p><p>Note: in Python, strings are immutable, we used the list <code>result</code> to append letters and later joined the list with an empty string to return it as a string object. The <code>join</code> operation takes linear time equal to the length of <code>results</code> to merge <code>results</code> with empty string.</p><h3 id=time>Time<a hidden class=anchor aria-hidden=true href=#time>#</a></h3><p>$O(m+n)$: m is the length of word1, n is the length of word2.</p><h3 id=space>Space<a hidden class=anchor aria-hidden=true href=#space>#</a></h3><p>$O(n)$: we use a temp list <code>result</code> to store the final string.</p><h2 id=approach-2-one-pointer>Approach 2: One pointer<a hidden class=anchor aria-hidden=true href=#approach-2-one-pointer>#</a></h2><p>To traverse two lists throughly, we could also check for <code>i &lt; max(len(word1), len(word2))</code>.</p><p>Inside while/for loop, result list appends words1[i] <code>if i &lt; len(words1)</code> and words2[j] <code>if j &lt; len(words2)</code>.</p><h1 id=1071-greatest-common-divisor-of-stringshttpsleetcodecomproblemsgreatest-common-divisor-of-strings><a href=https://leetcode.com/problems/greatest-common-divisor-of-strings/>1071. Greatest Common Divisor of Strings</a><a hidden class=anchor aria-hidden=true href=#1071-greatest-common-divisor-of-stringshttpsleetcodecomproblemsgreatest-common-divisor-of-strings>#</a></h1><h2 id=approach-1-analgous-to-math-gcd>Approach 1: Analgous to math GCD<a hidden class=anchor aria-hidden=true href=#approach-1-analgous-to-math-gcd>#</a></h2><p>Denote len(str1) = m, len(str1) = n.</p><p>if m > n, gcdString = gcd(str1 - str2, str2), and vice versa. str1 - str2 means deleting str2 from the start of str1. If there is any mismatch, then there is no gcd string (return "" as gcdString).</p><p>Base case: if str1 == &ldquo;&rdquo;, return str2; vice versa</p><h3 id=time-1>Time<a hidden class=anchor aria-hidden=true href=#time-1>#</a></h3><p>We need to scan the longest string of str1 and str2 once: $O(max(m+n))$</p><h3 id=space-1>Space<a hidden class=anchor aria-hidden=true href=#space-1>#</a></h3><p>$O(1)$ if we can modify string in place.</p><h1 id=605-can-place-flowershttpsleetcodecomproblemscan-place-flowers><a href=https://leetcode.com/problems/can-place-flowers/>605. Can Place Flowers</a><a hidden class=anchor aria-hidden=true href=#605-can-place-flowershttpsleetcodecomproblemscan-place-flowers>#</a></h1><h2 id=approach>Approach<a hidden class=anchor aria-hidden=true href=#approach>#</a></h2><p>Greedy algorithm + padding the front and the end of the array. If a spot is plantable, then +2 to find the next via spot.</p><p>If the array is not allowed to change, we could create a new array with paddings, or we could handle the front and end very carefully.</p><p>We could return True early if n is already 0 (assuming each time we find a spot we decrement n by 1).</p><h3 id=time-2>Time<a hidden class=anchor aria-hidden=true href=#time-2>#</a></h3><p>We need to scan the array once: $O(n)$.</p><h3 id=space-2>Space<a hidden class=anchor aria-hidden=true href=#space-2>#</a></h3><p>$O(1)$</p><h1 id=345-reverse-vowels-of-a-stringhttpsleetcodecomproblemsreverse-vowels-of-a-string><a href=https://leetcode.com/problems/reverse-vowels-of-a-string/>345. Reverse Vowels of a String</a><a hidden class=anchor aria-hidden=true href=#345-reverse-vowels-of-a-stringhttpsleetcodecomproblemsreverse-vowels-of-a-string>#</a></h1><h2 id=approach-1>Approach<a hidden class=anchor aria-hidden=true href=#approach-1>#</a></h2><ol><li>Python string is immutable. First convert input string to a list to enable in-place swap. After that, use <code>"".join(stringList)</code> to convert the list back to string.</li><li>Use a dictionary to store the vowels.</li><li>Use double pointers, one pointing at the front, and another pointing at the back. Use a while loop to make sure they do not cross.</li><li>Inside the while loop: use two while loops for i and j to find vowels, and make sure they do not touch. If they haven&rsquo;t touched after the two while loops, then they must find a pair of vowels => we do the swap.</li></ol><h3 id=time-3>Time<a hidden class=anchor aria-hidden=true href=#time-3>#</a></h3><p>We need to scan the string once: $O(n)$.</p><h3 id=space-3>Space<a hidden class=anchor aria-hidden=true href=#space-3>#</a></h3><p>$O(n)$</p><h1 id=151-reverse-words-in-a-stringhttpsleetcodecomproblemsreverse-words-in-a-string><a href=https://leetcode.com/problems/reverse-words-in-a-string/>151. Reverse Words in a String</a><a hidden class=anchor aria-hidden=true href=#151-reverse-words-in-a-stringhttpsleetcodecomproblemsreverse-words-in-a-string>#</a></h1><h2 id=approach-2>Approach<a hidden class=anchor aria-hidden=true href=#approach-2>#</a></h2><ol><li>Similar to the above problem. Use <code>.split()</code> split a string into a list of words. The default delimiter to <code>split</code> is any number of white spaces.</li><li>Use double pointers to swap.</li></ol><h3 id=time-4>Time<a hidden class=anchor aria-hidden=true href=#time-4>#</a></h3><p>$O(n)$</p><h3 id=space-4>Space<a hidden class=anchor aria-hidden=true href=#space-4>#</a></h3><p>$O(n)$</p><h1 id=1137-n-th-tribonacci-numberhttpsleetcodecomproblemsn-th-tribonacci-number><a href=https://leetcode.com/problems/n-th-tribonacci-number/>1137. N-th Tribonacci Number</a><a hidden class=anchor aria-hidden=true href=#1137-n-th-tribonacci-numberhttpsleetcodecomproblemsn-th-tribonacci-number>#</a></h1><h2 id=approach-3>Approach<a hidden class=anchor aria-hidden=true href=#approach-3>#</a></h2><p>To solve it and not use recursion, which is of exponential complexity, we use a dynamic programming technique:</p><ul><li>use an array of size n+1 to store the partial results along computing $T_n$</li><li>initialize $T_0, T_1, T_2$</li><li>use for loop to compute $T_n$</li></ul><h3 id=time-5>Time:<a hidden class=anchor aria-hidden=true href=#time-5>#</a></h3><p>$O(n)$</p><h3 id=space-5>Space<a hidden class=anchor aria-hidden=true href=#space-5>#</a></h3><p>$O(n)$</p><h1 id=238-product-of-array-except-selfhttpsleetcodecomproblemsproduct-of-array-except-self><a href=https://leetcode.com/problems/product-of-array-except-self/>238. Product of Array Except Self</a><a hidden class=anchor aria-hidden=true href=#238-product-of-array-except-selfhttpsleetcodecomproblemsproduct-of-array-except-self>#</a></h1><h2 id=approach-4>Approach<a hidden class=anchor aria-hidden=true href=#approach-4>#</a></h2><p>For each number in the array, to get the product of everything besides it, we can divide the problem into two halves: multiply the numbers on the left and store the result, then multiply the numbers on the right.</p><p>The key point is to store the partial result in an variable, and update the slots in the output array with the corresponding partial result.</p><h3 id=time-6>Time:<a hidden class=anchor aria-hidden=true href=#time-6>#</a></h3><p>$O(n)$</p><h3 id=space-6>Space<a hidden class=anchor aria-hidden=true href=#space-6>#</a></h3><p>$O(1)$</p><h1 id=283-move-zeroeshttpsleetcodecomproblemsmove-zeroes><a href=https://leetcode.com/problems/move-zeroes/>283. Move Zeroes</a><a hidden class=anchor aria-hidden=true href=#283-move-zeroeshttpsleetcodecomproblemsmove-zeroes>#</a></h1><h2 id=approach-1-1>Approach 1<a hidden class=anchor aria-hidden=true href=#approach-1-1>#</a></h2><p>This problem is under the section <em>Two Pointers</em>. I approach this problem by setting the one pointer to keep track of the first 0 on the left (the first swap position), and the other pointer to the next non-zero number (use a while loop).</p><h2 id=approach-2-fast-and-slow-pointer>Approach 2: Fast and Slow pointer<a hidden class=anchor aria-hidden=true href=#approach-2-fast-and-slow-pointer>#</a></h2><p>The fast pointer iterates faster than the slower one. But they should end at about the same time. So I use a for loop to iterates the fast pointer over the whole array, and only updates the slow pointer if it points to a non-zero. Like the previous approach, essentially the fast will keep track of the non-zero, the slow keeps track of the first zero. But the structure of a for loop to update the fast, and inside the loop an if to conditionally update slow is much cleaner than approach 1.</p><h3 id=time-7>Time:<a hidden class=anchor aria-hidden=true href=#time-7>#</a></h3><p>$O(n)$</p><h3 id=space-7>Space<a hidden class=anchor aria-hidden=true href=#space-7>#</a></h3><p>$O(1)$</p><h1 id=392-is-subsequencehttpsleetcodecomproblemsis-subsequence><a href=https://leetcode.com/problems/is-subsequence/>392. Is Subsequence</a><a hidden class=anchor aria-hidden=true href=#392-is-subsequencehttpsleetcodecomproblemsis-subsequence>#</a></h1><h2 id=approach-fast-and-slow-pointer>Approach: fast and slow pointer<a hidden class=anchor aria-hidden=true href=#approach-fast-and-slow-pointer>#</a></h2><p>To check if s is a substring of t, the fast pointer iterates over t, and the slow pointer iterates over s. If the iterator of s points to beyond the end of s, then we know s is a substring of t. We also use a similair structure to the above problem: a for loop for t; inside for loop, use a if to iterate s if we find a characet match.</p><h3 id=time-8>Time:<a hidden class=anchor aria-hidden=true href=#time-8>#</a></h3><p>$O(n)$</p><h3 id=space-8>Space<a hidden class=anchor aria-hidden=true href=#space-8>#</a></h3><p>$O(1)$</p><h1 id=643-maximum-average-subarray-ihttpsleetcodecomproblemsmaximum-average-subarray-i><a href=https://leetcode.com/problems/maximum-average-subarray-i/>643. Maximum Average Subarray I</a><a hidden class=anchor aria-hidden=true href=#643-maximum-average-subarray-ihttpsleetcodecomproblemsmaximum-average-subarray-i>#</a></h1><h2 id=approach-sliding-window>Approach: Sliding window<a hidden class=anchor aria-hidden=true href=#approach-sliding-window>#</a></h2><p>If we were to average every window, the complexity is $O(k*n)$. To make it linearly dependent on n, we observe that for each window, we only need to keep track of the changes between each window: subtract the left, add the right. My first thought was if we can find an i such that <code>nums[i] &lt; nums[i+k]</code>, then we update <code>maxI</code> to this new <code>i</code>. However, this only work locally, namely, if we compare two contiguous windows. It doesn&rsquo;t word between two non-neighbors since they do not share the middle two elements. Thus, we also need to track the <code>sum</code> and <code>maxSum</code>.</p><h3 id=time-9>Time:<a hidden class=anchor aria-hidden=true href=#time-9>#</a></h3><p>$O(n)$</p><h3 id=space-9>Space<a hidden class=anchor aria-hidden=true href=#space-9>#</a></h3><p>$O(1)$</p><h1 id=724-find-pivot-indexhttpsleetcodecomproblemsfind-pivot-index><a href=https://leetcode.com/problems/find-pivot-index/>724. Find Pivot Index</a><a hidden class=anchor aria-hidden=true href=#724-find-pivot-indexhttpsleetcodecomproblemsfind-pivot-index>#</a></h1><h2 id=approach-sliding-window-1>Approach: Sliding window<a hidden class=anchor aria-hidden=true href=#approach-sliding-window-1>#</a></h2><p>Use <code>leftSum</code> and <code>rightSum</code> to store the sum of left and right elements of the potential pivot. If <code>leftSum == rightSum</code>, we find the pivot.</p><p>We use the sliding window approach to update <code>leftSum</code> and <code>rightSum</code>. Init <code>leftSum</code> to 0 and <code>rightSum</code> to <code>sum(nums)-nums[0]</code> for <code>i=0</code> .</p><h3 id=time-10>Time:<a hidden class=anchor aria-hidden=true href=#time-10>#</a></h3><p>$O(n)$</p><h3 id=space-10>Space<a hidden class=anchor aria-hidden=true href=#space-10>#</a></h3><p>$O(1)$</p><h1 id=2215-find-the-difference-of-two-arrayshttpsleetcodecomproblemsfind-the-difference-of-two-arrays><a href=https://leetcode.com/problems/find-the-difference-of-two-arrays/>2215. Find the Difference of Two Arrays</a><a hidden class=anchor aria-hidden=true href=#2215-find-the-difference-of-two-arrayshttpsleetcodecomproblemsfind-the-difference-of-two-arrays>#</a></h1><h2 id=approach-set-difference>Approach: set difference<a hidden class=anchor aria-hidden=true href=#approach-set-difference>#</a></h2><p><code>answer[0] = set(nums1) - set(nums2)</code></p><p><code>answer[1] = set(nums2) - set(nums1)</code></p><h3 id=time-11>Time:<a hidden class=anchor aria-hidden=true href=#time-11>#</a></h3><p>$O(n)$</p><h3 id=space-11>Space<a hidden class=anchor aria-hidden=true href=#space-11>#</a></h3><p>$O(n)$</p><h1 id=1207-unique-number-of-occurrenceshttpsleetcodecomproblemsunique-number-of-occurrences><a href=https://leetcode.com/problems/unique-number-of-occurrences/>1207. Unique Number of Occurrences</a><a hidden class=anchor aria-hidden=true href=#1207-unique-number-of-occurrenceshttpsleetcodecomproblemsunique-number-of-occurrences>#</a></h1><h2 id=approach-5>Approach<a hidden class=anchor aria-hidden=true href=#approach-5>#</a></h2><p>Create a dictionary; Loop through the array, and insert the element into the dictionary or increment the counter for the existing key; If the size of the dictionary (number of keys) is the same as the unique values of the counters of those keys, then we know each key (each unique element in array) has a unique number of appearances.</p><h3 id=time-12>Time:<a hidden class=anchor aria-hidden=true href=#time-12>#</a></h3><p>$O(n)$</p><h3 id=space-12>Space<a hidden class=anchor aria-hidden=true href=#space-12>#</a></h3><p>$O(n)$</p><h1 id=2390-removing-stars-from-a-stringhttpsleetcodecomproblemsremoving-stars-from-a-string><a href=https://leetcode.com/problems/removing-stars-from-a-string/>2390. Removing Stars From a String</a><a hidden class=anchor aria-hidden=true href=#2390-removing-stars-from-a-stringhttpsleetcodecomproblemsremoving-stars-from-a-string>#</a></h1><h2 id=approach-6>Approach<a hidden class=anchor aria-hidden=true href=#approach-6>#</a></h2><p>To &ldquo;Remove the closest <strong>non-star</strong> character to its <strong>left</strong>, as well as remove the star itself&rdquo;, we can use a stack to simulate this process: read the string from left to right (start to end), when we see a non star, we push it to the stack. When we see a star, we pop the last element we pushed (LIFO).</p><p>In Python, we can use <code>deque</code> in <code>collections</code>, because it offers $O(1)$ insertion at both the right end (<code>append</code>) and the left enb (<code>appendleft</code>) and $O(1)$ pop (<code>pop</code>) at the right and the left end (<code>popleft</code>).</p><h3 id=time-13>Time:<a hidden class=anchor aria-hidden=true href=#time-13>#</a></h3><p>$O(n)$</p><h3 id=space-13>Space<a hidden class=anchor aria-hidden=true href=#space-13>#</a></h3><p>$O(1)$</p><h1 id=735-asteroid-collisionhttpsleetcodecomproblemsasteroid-collision><a href=https://leetcode.com/problems/asteroid-collision/>735. Asteroid Collision</a><a hidden class=anchor aria-hidden=true href=#735-asteroid-collisionhttpsleetcodecomproblemsasteroid-collision>#</a></h1><h2 id=approach-7>Approach<a hidden class=anchor aria-hidden=true href=#approach-7>#</a></h2><p>Use <code>deque</code> to simulate stack in python. Make sure the element to be pushed on top of the stack is compatible with elements inside the stack before pushing it.</p><p>Invariants:</p><ol><li>If the stack is empty, push the next element in the array.</li><li>If the top element in the stack is negative, push the next element in array no matter it is negative or positive.</li><li>If the next element is positive, just push it.</li><li>Else (top is positive, next element is negative): crush whatever can be crushed by the next element in the stack: a while loop</li></ol><h3 id=time-14>Time:<a hidden class=anchor aria-hidden=true href=#time-14>#</a></h3><p>$O(n^2)$</p><h3 id=space-14>Space<a hidden class=anchor aria-hidden=true href=#space-14>#</a></h3><p>$O(1)$</p><h1 id=933-number-of-recent-callshttpsleetcodecomproblemsnumber-of-recent-calls><a href=https://leetcode.com/problems/number-of-recent-calls/>933. Number of Recent Calls</a><a hidden class=anchor aria-hidden=true href=#933-number-of-recent-callshttpsleetcodecomproblemsnumber-of-recent-calls>#</a></h1><h2 id=approach-8>Approach<a hidden class=anchor aria-hidden=true href=#approach-8>#</a></h2><p>t is in strictly increasing order. If some ping falls outside of the range, it must be in the start of the ping array. This behavior can be simulated using queue (FIFO).</p><p>In python, we can use <code>deque</code> to implement a queue: <code>append</code> to push, <code>popleft</code> to pop.</p><h3 id=time-15>Time:<a hidden class=anchor aria-hidden=true href=#time-15>#</a></h3><p>$O(n)$</p><h3 id=space-15>Space<a hidden class=anchor aria-hidden=true href=#space-15>#</a></h3><p>$O(1)$</p><h1 id=2095-delete-the-middle-node-of-a-linked-listhttpsleetcodecomproblemsdelete-the-middle-node-of-a-linked-list><a href=https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/>2095. Delete the Middle Node of a Linked List</a><a hidden class=anchor aria-hidden=true href=#2095-delete-the-middle-node-of-a-linked-listhttpsleetcodecomproblemsdelete-the-middle-node-of-a-linked-list>#</a></h1><h2 id=approach-9>Approach<a hidden class=anchor aria-hidden=true href=#approach-9>#</a></h2><p>To fid the middle node, we could use the &ldquo;fast&rdquo; and &ldquo;slow&rdquo; double pointer method. Inside the while loop, by updating the &ldquo;fast&rdquo; pointer twice and the &ldquo;slow&rdquo; pointer once, we can locate the mid node at the &ldquo;slow&rdquo; pointer.</p><p>To delete it, we can use another pointer to point to the prev of the &ldquo;slow&rdquo; pointer, and update <code>prev.next</code> to its <code>next.next</code>.</p><h3 id=time-16>Time:<a hidden class=anchor aria-hidden=true href=#time-16>#</a></h3><p>$O(n)$</p><h3 id=space-16>Space<a hidden class=anchor aria-hidden=true href=#space-16>#</a></h3><p>$O(1)$</p><h1 id=328-odd-even-linked-listhttpsleetcodecomproblemsodd-even-linked-list><a href=https://leetcode.com/problems/odd-even-linked-list/>328. Odd Even Linked List</a><a hidden class=anchor aria-hidden=true href=#328-odd-even-linked-listhttpsleetcodecomproblemsodd-even-linked-list>#</a></h1><h2 id=appraoch>Appraoch<a hidden class=anchor aria-hidden=true href=#appraoch>#</a></h2><p>The intuition is to maintain a double-pointer structure to this linked-list: the <code>oddNode</code> pointer that first points to the <code>head</code> and the <code>evenNode</code> pointer that first points to <code>head.next</code> .</p><p>My first try was to update <code>oddNode.next = oddNode.next.next</code> in a while loop, which essentially gets the oddNode list ready. Then I update the evenNode list similarly. But this did not work, because <code>evenNode.next</code> is the updated oddNode not the original oddNode, and <code>evenNode.next.next</code> is not a evenNode.</p><p>To account for that, we need to carefully update oddNode and evenNode <em>in turn</em>. Another thing is that we need to store the head.next in a special variable <code>evenListStart</code> so that the last oddNode knows where it should point to. The last evenNode should point to <code>None</code>.</p><h3 id=time-17>Time:<a hidden class=anchor aria-hidden=true href=#time-17>#</a></h3><p>$O(n)$</p><h3 id=space-17>Space<a hidden class=anchor aria-hidden=true href=#space-17>#</a></h3><p>$O(1)$</p><h1 id=206-reverse-linked-listhttpsleetcodecomproblemsreverse-linked-list><a href=https://leetcode.com/problems/reverse-linked-list/>206. Reverse Linked List</a><a hidden class=anchor aria-hidden=true href=#206-reverse-linked-listhttpsleetcodecomproblemsreverse-linked-list>#</a></h1><h2 id=approach-10>Approach<a hidden class=anchor aria-hidden=true href=#approach-10>#</a></h2><p>We traverse the linked list and do this:</p><ol><li>Store <code>currentNode.next</code> to <code>nextNode</code>.</li><li>Set <code>currentNode.next</code> to <code>prevNode</code></li><li>Update <code>prevNode</code> to <code>currentNode</code></li><li>Update <code>currentNode</code> to <code>nextNode</code></li><li>We need to handle the head and the end of the list a little differently:<ol><li>head of the list does not have <code>prevNode</code>: therefore in step 2, set it to <code>None</code>.</li><li>End of the list does not have <code>nextNode</code> (equals <code>None</code>), if we know it is <code>None</code>, we know it is the end and we set it to be the new <code>head</code>.</li></ol></li></ol><h3 id=time-18>Time:<a hidden class=anchor aria-hidden=true href=#time-18>#</a></h3><p>$O(n)$</p><h3 id=space-18>Space<a hidden class=anchor aria-hidden=true href=#space-18>#</a></h3><p>$O(1)$</p><h1 id=104-maximum-depth-of-binary-treehttpsleetcodecomproblemsmaximum-depth-of-binary-tree><a href=https://leetcode.com/problems/maximum-depth-of-binary-tree/>104. Maximum Depth of Binary Tree</a><a hidden class=anchor aria-hidden=true href=#104-maximum-depth-of-binary-treehttpsleetcodecomproblemsmaximum-depth-of-binary-tree>#</a></h1><h2 id=background-tree-traversal>Background: Tree traversal<a hidden class=anchor aria-hidden=true href=#background-tree-traversal>#</a></h2><p>Unlike linear data structures (Array, Linked List, Queues, Stacks, etc) which have only one logical way to traverse them, trees can be traversed in different ways.</p><h3 id=traversal-using-dfs>Traversal using DFS<a hidden class=anchor aria-hidden=true href=#traversal-using-dfs>#</a></h3><h4 id=inorder-traversal-left-root-right>Inorder Traversal (left, root, right)<a hidden class=anchor aria-hidden=true href=#inorder-traversal-left-root-right>#</a></h4><p>Inorder traversal gives nodes in non-decreasing order.</p><h5 id=implementation>Implementation:<a hidden class=anchor aria-hidden=true href=#implementation>#</a></h5><ul><li>Iterative:<ul><li>Keep appending left nodes to the stack until hitting None</li><li>Pop the stack to get the node and print it. Go to its right. Goes back to the above step.</li></ul></li><li>Recursive:<ul><li>InorderTravese(root.left)</li><li>Print (root)</li><li>InorderTravese(root.right)</li></ul></li></ul><h5 id=time-and-space>Time and Space<a hidden class=anchor aria-hidden=true href=#time-and-space>#</a></h5><p>Time: $O(n)$</p><p>Space: $O(h)$, $h$ is the height of the tree. In the iterative case, $h = len(stack)$. In the recursive case: $h = len(functionStack)$</p><h4 id=preorder-traversal-root-left-right>Preorder Traversal (root, left, right)<a hidden class=anchor aria-hidden=true href=#preorder-traversal-root-left-right>#</a></h4><p>Preorder traversal is used to create a copy of the tree.</p><h5 id=implementation-1>Implementation:<a hidden class=anchor aria-hidden=true href=#implementation-1>#</a></h5><ul><li><p>Iterative: <em>The right child is pushed before the left child to make sure that the left subtree is processed first.</em></p><ul><li>Pop an item from the stack and print it.</li><li>Push right child of a popped item to stack</li><li>Push left child of a popped item to stack</li></ul></li><li><p>Recursive:</p><ul><li>Print (root)</li><li>PreorderTravese(root.left)</li><li>PreorderTravese(root.right)</li></ul></li></ul><h5 id=time-and-space-1>Time and Space<a hidden class=anchor aria-hidden=true href=#time-and-space-1>#</a></h5><p>The same as InorderTraverse.</p><h4 id=postorder-traversal-left-right-root>Postorder Traversal (left, right, root)<a hidden class=anchor aria-hidden=true href=#postorder-traversal-left-right-root>#</a></h4><p>Postorder traversal is used to delete the tree.</p><h3 id=level-order-traversal-bfs-traversal>Level Order Traversal (BFS Traversal)<a hidden class=anchor aria-hidden=true href=#level-order-traversal-bfs-traversal>#</a></h3><p>Traverse all the nodes of a lower level before moving to any of the nodes of a higher level.</p><h5 id=implementation-2>Implementation<a hidden class=anchor aria-hidden=true href=#implementation-2>#</a></h5><ul><li>Iterative:<ul><li>Visit the root and push all its children to the queue.</li><li>Pop the queue and visit the popped node and push all its children to queue. Repeat until queue is empty.</li></ul></li></ul><h2 id=approach-11>Approach<a hidden class=anchor aria-hidden=true href=#approach-11>#</a></h2><h3 id=recursively>Recursively<a hidden class=anchor aria-hidden=true href=#recursively>#</a></h3><p>Using DFS. If the node is None, return 0. Otherwise, return <code>max(maxDepth(node.left), maxDepth(node.right)) + 1</code></p><h3 id=time-19>Time:<a hidden class=anchor aria-hidden=true href=#time-19>#</a></h3><p>$O(n)$</p><h3 id=space-19>Space<a hidden class=anchor aria-hidden=true href=#space-19>#</a></h3><p>$O(h)$: h = Max height of the tree.</p><h1 id=338-counting-bitshttpsleetcodecomproblemscounting-bits><a href=https://leetcode.com/problems/counting-bits/>338. Counting Bits</a><a hidden class=anchor aria-hidden=true href=#338-counting-bitshttpsleetcodecomproblemscounting-bits>#</a></h1><h2 id=approach-12>Approach<a hidden class=anchor aria-hidden=true href=#approach-12>#</a></h2><p>To do it in linear time, the intuition is to use dynamic programming: reuse the result in smaller <code>i</code>s (i from 1 to n) to compute big <code>i</code>s.</p><p>One way to do this is to divide <code>i</code> by 2 by using <code>i>>1</code> and access <code>output[i>>1]</code> to get the number of 1s besides the last digit. If the last digit is 1, then we add 1 to the above number; otherwise, add 0. To check if the last digit is 1 or not, we can use <code>i&amp;1</code>.</p><h3 id=time-20>Time:<a hidden class=anchor aria-hidden=true href=#time-20>#</a></h3><p>$O(n)$</p><h3 id=space-20>Space<a hidden class=anchor aria-hidden=true href=#space-20>#</a></h3><p>$O(1)$</p><h1 id=136-single-numberhttpsleetcodecomproblemssingle-number><a href=https://leetcode.com/problems/single-number/>136. Single Number</a><a hidden class=anchor aria-hidden=true href=#136-single-numberhttpsleetcodecomproblemssingle-number>#</a></h1><p>Since besides the singled number the list contains numbers all in pair. To cancel themselves out, we can use xor (<code>^</code> in python). We can xor the whole list together and what remains is the single number.</p><h3 id=time-21>Time:<a hidden class=anchor aria-hidden=true href=#time-21>#</a></h3><p>$O(n)$</p><h3 id=space-21>Space<a hidden class=anchor aria-hidden=true href=#space-21>#</a></h3><p>$O(1)$</p><h1 id=1-two-sumhttpsleetcodecomproblemstwo-sum><a href=https://leetcode.com/problems/two-sum/>1. Two Sum</a><a hidden class=anchor aria-hidden=true href=#1-two-sumhttpsleetcodecomproblemstwo-sum>#</a></h1><h2 id=approach-13>Approach<a hidden class=anchor aria-hidden=true href=#approach-13>#</a></h2><p>I did not figure it out myself. The most obvious solution is to use a $O(n^2)$ brute-force method. I then try to reduce it to $O(n\log{n})$ by first sorting it, and then use binary search to search for each element&rsquo;s complement in the list. That is another $O(n\log{n})$. This doesn&rsquo;t work becasue the numbers could be negative and the target sum could be acheived by summing</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://allanware.github.io/posts/2023/11/biased-average-position-estimates-in-line-and-bar-graphs/><span class=title>« Prev</span><br><span>Biased Average Position Estimates in Line and Bar Graphs</span>
</a><a class=next href=https://allanware.github.io/posts/2023/08/visualization-x-psychology/><span class=title>Next »</span><br><span>Visualization x Psychology</span></a></nav></footer><script src=https://utteranc.es/client.js repo=Allanware/allanware.github.io issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://allanware.github.io/>Wenxuan Zhao</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>